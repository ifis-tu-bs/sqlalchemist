%!TEX root = ../Systementwurf2.tex

\chapter{Implementierungsentwurf}

Die Implementierung des \NewsGenie erfolgt eventbasiert. Der Austausch von
Nachrichtenobjekten dient dabei der Kommunikation unter den einzelnen
Komponenten. Im Folgenden werden die Komponenten und ihre Funktionen erläutert.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{Systementwurf/05_implementierungsentwurf/komponenten}
\caption{Komponentendiagramm, \textit{Komponentenaufteilung von \NewsGenie}}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{Systementwurf/05_implementierungsentwurf/paket-queryprocessor}
\caption{Komponentendiagramm, \textit{Komponenten des Queryprocessors}}
\end{figure}

\FloatBarrier

% C10 Client

\section{Implementierung von Komponente $\langle$C10$\rangle$: Client}

Der Client dient als Frontend des \NewsGenie. Für die Kommunikation mit dem
Server wird das Akka-Framework genutzt. Der Client wird eventbasiert realisiert
und nach dem Start durch den \textit{ServerHandler} gesteuert.

\subsection{Paket-/Klassendiagramm}

\begin{figure}[ht]
\centering
\includegraphics[width=1.03\textwidth]{Systementwurf/05_implementierungsentwurf/client-objekte}
\caption{Klassendiagramm für Komponente \ref{C10}}
\end{figure}

\subsection{Erläuterung}

Im Folgenden werden Attribute, Aufgaben und Kommunikationspartner für jede
Klasse des Clients kurz zu erläutern. Get-/Set-Methoden werden dabei nicht
berücksichtigt, sondern nur deren Attribute als \texttt{private} mit einem
Minuszeichen gekennzeichnet.

\pagebreak[4]
\begin{class}{10}{Client}
\item[Aufgabe]~\
Hauptklasse des Clients. Initialisierung der einzelnen Singleton-Objekte die zum
Bearbeiten einer Anfrage notwendig sind.
\item[Attribute]~\
\begin{itemize}
  \item \texttt{textmode}: falls \texttt{true} akzeptiert der Client
  Tastatureingaben statt Spracheingaben
\end{itemize}
\item[Operationen]~\
\begin{itemize}
  \item \texttt{nextInput()}: startet die nächste Eingabe durch Aufruf des
  \textit{Recognizers}. Der Aufruf erfolgt entweder per Tastendruck oder durch
  den \textit{ServerHandler}.
\end{itemize}
\item[Kommunikationspartner]~\
  \textit{Recognizer}, \textit{ServerHandler}
\end{class}

\begin{class}{10}{Recognizer}
\item[Aufgabe]~\
Realisiert die Umwandlung der Sprachbefehle in Text.
\item[Attribute]~\
keine
\item[Operationen]~\
\begin{itemize}
    \item \texttt{getRecognizedDataForWave(File waveFile, int maxResults)}
    schickt eine Wave-Datei an die Speech-API und erhält ein
    \texttt{GoogleResponse}-Objekt zurück.
    \item \texttt{getRecognizedDataForFlac(File flacFile, int maxResults)}
    schickt eine Flac-Datei an die Speech-API und erhält ein 
    \texttt{GoogleResponse}-Objekt zurück.
    \item \texttt{parseResponse(GoogleResponse response)} wertet ein
    \texttt{GoogleResponse}-Objekt aus und gibt die erkannte Anfrage als String
    zurück.
    \item \texttt{startRecognizing()} steuert den Ablauf einer Anfrage über
    Aufzeichnung und Erkennung und gibt einen String zurück.
\end{itemize}
\item[Kommunikationspartner]~\
\textit{RecordAudio}, \textit{FlacEncoder}, \textit{GoogleResponse}
\end{class}

\begin{class}{10}{RecordAudio}
\item[Aufgabe]~\
Steuert die Audioaufnahme und Speicherung. Diese Klasse ist als Singleton
ausgelegt.
\item[Attribute]~\
keine
\item[Operationen]~\
\begin{itemize}
    \item \texttt{saveToFile(String name)} speichert eine erfolgte Audioaufnahme
    als Wave-Datei.
    \item \texttt{startRecording()} startet die Aufnahme über das Mikrofon,
    bricht ab, wenn der Pegel unter ein Limit fällt.
\end{itemize}
\item[Kommunikationspartner]~\
\textit{Recognizer}
\end{class}

\begin{class}{10}{FlacEncoder}
\item[Aufgabe]~\
Singleton-Klasse zur Umwandlung von Wave in Flac-Dateien.
\item[Attribute]~\
keine
\item[Operationen]~\
\begin{itemize}
    \item \texttt{convertWaveToFlac(File inputFile, File outputFile)} wandelt
    eine Wave-Datei in eine Flac-Datei um.
\end{itemize}
\item[Kommunikationspartner]~\
\textit{Recognizer}
\end{class}

\begin{class}{10}{GoogleResponse}
\item[Aufgabe]~\
Speicherung der Google Speech-API Antwortdaten
\item[Attribute]~\
\begin{itemize}
    \item \texttt{response} Antwort der Speech-API als String
    \item \texttt{confidence} prozentuale Sicherheit der erfolgten Erkennung als
    Double-Wert
\end{itemize}
\item[Operationen]~\
keine
\item[Kommunikationspartner]~\
\textit{Recognizer}
\end{class}

\begin{class}{10}{ServerHandler}
\item[Aufgabe]~\
Singleton-Klasse für die Serverkommunikation. Der Nachrichtenaustausch erfolgt
durch das Senden von Objekten zwischen Server und Client.
\item[Attribute]~\
\begin{itemize}
    \item \texttt{server} Akka-ActorRef-Object, dass auf den Server verweist.
\end{itemize}
\item[Operationen]~\
\begin{itemize}
    \item \texttt{onRecieve(Object message)}
\end{itemize}
\item[Kommunikationspartner]~\
\textit{Client}, \textit{Say}, \textit{ClientMessage}
\end{class}

\begin{class}{10}{Say}
\item[Aufgabe]~\
Singleton-Klasse zur Ausgabe von Text als Sprache.
\item[Attribute]~\
keine
\item[Operationen]~\
\begin{itemize}
    \item \texttt{text(String sentence)} wandelt einen String in eine Wave-Datei
    um und spielt diese ab.
\end{itemize}
\item[Kommunikationspartner]~\

\end{class}

\begin{class}{10}{ClientMessage}
\item[Aufgabe]~\
Superklasse der Nachrichten, die zwischen Server und Client ausgetauscht werden.
\item[Attribute]~\
\begin{itemize}
    \item \texttt{text} Text der Nachricht als String.
    \item \texttt{client} Akka-ActorRef-Objekt mit Verweis auf den absendenden
    Client.
    \item \texttt{user} auf dem Client angemeldeter Benutzer als User-Objekt.
    \item \texttt{uuid} einzigartige ID zur Identifikation der Nachricht.
    \item \texttt{parent} enthält evtl. ein Objekt, dass der Server zur weiteren
    Auswertung mit an den Client übergeben möchte, z.B. eine Liste von Artikeln.
\end{itemize}
\item[Operationen]~\
keine
\item[Kommunikationspartner]~\
\textit{ServerHandler}
\end{class}

\begin{class}{10}{ClientAnswer}
\item[Aufgabe]~\
Objekt zur Übertragung einer Serverantwort an den Client
\item[Attribute]~\
Attribute der Superklasse, sowie
\begin{itemize}
    \item \texttt{secure} Bool'scher Wert, \textit{true} falls die Antwort
    sicher ist und ohne Rückfrage auskommt.
\end{itemize}
\item[Operationen]~\
keine
\item[Kommunikationspartner]~\
\textit{ServerHandler}
\end{class}

\begin{class}{10}{ClientQuery}
\item[Aufgabe]~\
Objekt zur Übertragung einer Clientanfrage an den Server
\item[Attribute]~\
nur Attribute der Superklasse
\item[Operationen]~\
keine
\item[Kommunikationspartner]~\
\textit{ServerHandler}
\end{class}

\begin{class}{10}{ClientLogin}
\item[Aufgabe]~\
Objekt zur Übertragung einer Loginanfrage vom Client zum Server
\item[Attribute]~\
nur Attribute der Superklasse
\item[Operationen]~\
keine
\item[Kommunikationspartner]~\
\textit{ServerHandler}
\end{class}

\FloatBarrier

% C20 Webinterface
\input{Systementwurf/implementierung/webinterface.tex}

% C30 Datenbank
\input{Systementwurf/implementierung/datenbank.tex}

% C40 Crawler
\section{Implementierung von Komponente <C40>: Crawler}

Der Crawler dient als Informationslieferant des \NewsGenies. Für die
Kommunikation mit der Datenbank wird das Akka-Framework genutzt. Der Crawler
ruft bei Start eines Crawl-Durchlaufs die Liste der Feeds von der Datenbank
ab und wiederholt diese Operation solange der Server läuft.

\subsection{Paket-/Klassendiagramm}

\begin{figure}[ht]
\centering
\includegraphics[width=1.03\textwidth]{Systementwurf/05_implementierungsentwurf/crawler-objekte}
\caption{Klassendiagramm für Komponente \ref{C10}}
\end{figure}
 
\subsection{Erläuterung}

Im Folgenden werden Attribute, Aufgaben und Kommunikationspartner für jede
Klasse der Serverkomponenten kurz erläutert. Triviale Methoden werden dabei
nicht berücksichtigt, sondern nur deren Attribute als \texttt{private} mit einem
Minuszeichen gekennzeichnet.

\begin{class}{40}{CrawlerHandler}
\item[Aufgabe]~\
Hauptklasse des Crawlers. Initialisierung der einzelnen Singleton-Objekte die
zum Bearbeiten eines Crawlvorgangs notwendig sind.
\item[Attribute]~\
\begin{itemize}
  \item \texttt{tripleMaker}: TripleMaker-Instanz
  \item \texttt{crawler}: Crawler-Instanz
  \item \texttt{databaseActor}: Akka-ActorRef-Objekt mit Verweis auf den
  DatabaseHandler
\end{itemize}
\item[Operationen]~\
\begin{itemize}
  \item \texttt{CrawlerHandler(ActorRef databaseActor)}:
  Instanziert die unter Attribute genannten Werte und sendet der
  Datenbank ein CrawlFeedListRequest. 
  \item \texttt{onRecive(Object message)}: Behandlet die eingehenden Messages:
\end{itemize}
\item[Kommunikationspartner]~\
  \textit{DatabaseHandler}
\end{class}

\begin{class}{40}{Crawler}
\item[Aufgabe]~\
Singleton-Klasse für das Crawlen der FeedList.
\item[Attribute]~\
keine
\item[Operationen]~\
\begin{itemize}
    \item \texttt{crawl(Feed feed)}: Crawlt von dem übergebenen Feed den Inhalt
    und lädt den Artikeltext.
\end{itemize}
\item[Kommunikationspartner]~\
\textit{CrawlerHandler}
\end{class}

\begin{class}{40}{TripleMaker}
\item[Aufgabe]~\
Singleton-Klasse für das Zerteilen der Artikeltexte in Triple für die Datenbank.
\item[Attribute]~\
\begin{itemize}
  \item \texttt{instance}: \texttt{TripleMaker}-Instanz für die verschiedenen 
  \item \texttt{pipeline}: \texttt{StandfortCoreNLP}-Instanz
  \item \texttt{lang}: Speichert die Sprache für die Triplezerlegung
\end{itemize}
\item[Operationen]~\
\begin{itemize}
    \item \texttt{TripleMaker(String lang)}: Instanziert die texttt{pipeline}
    mit den passenden Spracheinstellungen.
    \item \texttt{getInstance(String lang)}: Instanziert den texttt{TripleMaker}
    oder gibt eine schon bestehende Instanz zurück.
    \item \texttt{makeTriple(String text)}: Zerlegt den übergebenen Text in
    Triple.
\end{itemize}
\item[Kommunikationspartner]~\
\textit{CrawlerHandler}
\end{class}

\begin{class}{40}{CrawlFeedListRequest}
\item[Aufgabe]~\
Objekt zur Anfrage auf Erhalt der Feedliste.
\item[Attribute]~\
keine
\item[Operationen]~\
keine
\item[Kommunikationspartner]~\
\textit{DatabaseHandler}
\end{class}

\begin{class}{40}{CrawlResultRequest}
\item[Aufgabe]~\
Objekt zur Anfrage auf Aktualisierung der Datenbank.
\item[Attribute]~\
\begin{itemize}
  \item \texttt{articleMap}: Liste mit Artikeln der
  Feeds und den Triple aus den Texten.
\end{itemize}
\item[Operationen]~\
keine
\item[Kommunikationspartner]~\
\textit{DatabaseHandler}
\end{class}

\FloatBarrier

\section{Implementierung von Komponente $\langle$C50$\rangle$: Query-Processor}

Der QueryProcessor ist das Herzstück des \NewsGenies. Hier werden vom Benutzer
gestellte Fragen analysiert und erkannt, um anschließend dementschende Anfragen
an die Datenbank zu stellen. Die Ergebnisse
einer Suche werden dann für den Benutzer aufbereitet
und anschließend zum Client zurückgeschickt.

\subsection{Paket-/Klassendiagramm}

\begin{figure}[ht]
\centering
\includegraphics[width=1\textheight, angle=90]{Systementwurf/05_implementierungsentwurf/Diagramm1}
\caption{Klassendiagramm für Komponente \ref{C50}}
\end{figure}
 
\FloatBarrier

\subsection{Erläuterung}

Im Folgenden werden Attribute, Aufgaben und Kommunikationspartner für jede
Klasse der Serverkomponenten kurz erläutert. Triviale Methoden werden dabei
nicht berücksichtigt.

\begin{class}{50}{Analyser}
\item[Aufgabe]~\
Analysiert Wortbäume mit Suchmustern, durch die die gestellte Frage erkannt
werden kann.
\item[Attribute]~\
\begin{itemize}
\item \texttt{analyserObjects}: \texttt{HashMap<String, AnalyserObject[]>}:
Enthält zu einer Sprache AnalyserObjects.
\item \texttt{restriction}: \texttt{HashMap<String,
ArrayList<ArrayList<String[]>>>}: Enthält für eine Sprache Suchmuster für Restriktionen.
\item \texttt{ignoredNouns}: \texttt{HashMap<String, List<String>>}: Enthält
für eine Sprache eine Liste mit Wörter die ignoriert werden sollen.
\end{itemize}
\item[Operationen]~\
\begin{itemize}
\item \texttt{Analyser()}: Erstellt eine Instanz des Analysers.
\item \texttt{analyse(List<Tree> treeList)}: Analysiert eine Wort-Baum-Liste.
\item \texttt{analyseAll(Tree tree, AnalysedQuery analysedQuery, String lang)}:
Findet für einen gegebenen Wort-Baum eines Satzes in einer Sprache den Fragetyp und Schlüsselwörter heraus.
\item \texttt{getMatchingTree(Tree tree, ArrayList<ArrayList<String[]>> paths,
ArrayList<ArrayList<String[]>> badPaths)}: Sucht mithilfe eines gegebenen
Musters nach einer Struktur im Baum und gibt diese aus.
\item \texttt{matchesTree(Tree tree, ArrayList<ArrayList<String[]>> paths)}:
Prüft, ob ein Baum mit einem gegeben Muster übereinstimmt.
\item \texttt{getNounsRecursive(Tree tree, String lang, List<String> list)}:
Suche alle Nomen aus einem Baum heraus und fügt diese in eine Liste ein.
\item \texttt{deleteIgnored(List<String> list, String lang)}: Entfernt alle zu
ignorierende Wörter aus einer Liste.
\item \texttt{searchTree(Tree tree, String[] path, int i)}: Prüft, ob ein
gegebener Such-Pfad im Baum existiert.
\item \texttt{loadLanguages()}: Ließt Suchmuster einer Sprache in
AnalyserObject ein.
\end{itemize}
\item[Kommunikationspartner]~\
\textit{QueryHandler}
\end{class}

\begin{class}{50}{AnalysedObject}
\item[Aufgabe]~\
Enthält einen Fragetyp und ein Suchmuster, mit dem man den Fragetyp
identifizieren kann.
\item[Attribute]~\
\begin{itemize}
\item \texttt{qt}: \texttt{QuestionType} Der Fragetyp.
\item \texttt{paths}: \texttt{ArrayList<ArrayList<String[]>>} Das Suchmuster.
\end{itemize}
\item[Operationen]~\
keine
\item[Kommunikationspartner]~\
\textit{Analyser}
\end{class}

\begin{class}{50}{Searcher}
\item[Aufgabe]~\
Kommuniziert mit der Datenbank.
\item[Attribute]~\
keine
\item[Operationen]~\
\begin{itemize}
\item \texttt{Searcher(ActorRef databaseActor)}: Instanziert den Searcher
\item \texttt{search(Messages.ClientQuery originalQuery, AnalysedQuery aq)}:Sucht entsprechend der Fragestellung nach Ergebnissen.
\item \texttt{searchDB(SimpleSearchRequest simpleSearchRequest)}: Stellt anfragen an die Datenbank.
\end{itemize}
\item[Kommunikationspartner]~\
\textit{DatabaseHandler}, \textit{QueryHandler}
\end{class}

\begin{class}{50}{QueryHandler}
\item[Aufgabe]~\
Der QueryHandler organisiert die Analyse der Querries.
\item[Attribute]~\
keine
\item[Operationen]~\
\begin{itemize}
	\item \texttt{QueryHandler(ActorRef databaseActor)}: Instanziiert den QueryHandler.
	\item \texttt{onReceive(Object message)}: Nimmt ClientQuery-Nachrichten entgegen, und lässt diese analysieren.
\end{itemize}
\item[Kommunikationspartner]~\
\textit{NLP}, \textit{ManagementHandler}, \textit{Searcher}, \textit{ResultProcessor}, \textit{Analyser}
\end{class}

\begin{class}{50}{NLP}
\item[Aufgabe]~\
Zerlegt Texte in Wort-Bäume, die der Analyser verarbeiten kann.
\item[Attribute]~\
\begin{itemize}
\item \texttt{instance}: \texttt{HashMap<String, NLP>} Enthält die NLP Instanz einer Sprache.
\end{itemize}
\item[Operationen]~\
\begin{itemize}
\item \texttt{NLP(String lang)}: Instanziiert NLP für eine gegebene Sprache.
\item \texttt{getInstance(String lang)}: Gibt die NLP-Instanz der jeweiligen
Sprache aus.
\item \texttt{analyse(String text)}: Analysiert einen Text bezüglich seiner
Sprache und erstellt daraus eine Wort-Baumstruktur, in der die Bedeutung der
einzelner Wörter steht.
\end{itemize}
\item[Kommunikationspartner]~\
\textit{QueryHandler}
\end{class}

\begin{class}{50}{ResultProcessor}
\item[Aufgabe]~\
Generiert aus vorgefertigten Textbausteinen und
Ergebnissen eine Antwort.
\item[Attribute]~\ keine
\item[Operationen]~\
\begin{itemize}
\item \texttt{makeClientAnswer(ActorRef client, User user, DatabaseAnswer
answer)}: Produziert aus einer SearchAnswer eine ClientAnswer.
\end{itemize}
\item[Kommunikationspartner]~\
\textit{QueryHandler}
\end{class}

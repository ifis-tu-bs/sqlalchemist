%!TEX root = ../Testspezifikation.tex

\chapter{Testplan}

Im Folgenden wird der Testplan für SQL-Alchemist beschrieben. Dabei wird sowohl auf die zu testenden Komponenten als auch die bereits im Pflichtenheft beschriebenen Funktionen und Merkmale eingegangen. Außerdem wird noch das genaue Vorgehen bei der Durchführung der Tests aufgezeigt.

\section{Zu testende Komponenten}

Die Sofware besteht grundsätzlich aus zwei Komponenten: Front-End und Back-End.\\
Da diese jedoch auf verschiedene Weise an verschiedenen Teilen der Software beteiligt sind, sind folgend die verschiedenen Kernpunkte aufgelistet, die zur Bewertung der Funktionstüchtigkeit getestet werden müssen:

\begin{itemize}
\item \textbf{SQL Modul: }Das SQL Modul ist der Kern der Software. Der Zweck des Programms, nämlich der Unterstützung beim Erlernen der Datenbankanfragesprache SQL, wird hierüber realisiert. Daher muss besonders die korrekte Anzeige der Aufgaben und die automatische Bewertung getestet werden. Weiterhin soll eine simple Bedienbarkeit gewährleistet werden.
\item \textbf{Minispiel: }Das Minispiel stellt die zweite zentrale Komponente des Projektes dar und muss daher auch ausgiebig getestet werden. In diesem Fall liegt das Hauptaugenmerk auf der Spielbarkeit der einzelnen Level und die Einhaltung des Schwierigkeitsgrades.
\item \textbf{GUI: }Die grafische Oberfläche bildet die Schnittstelle zwischen Benutzer und Applikation. Daher muss hier geprüft werden, ob die Menüs auf allen Endgeräten korrekt angezeigt werden und intuitiv bedienbar sind.
\item \textbf{Datenbank: }Die Datenbank ist für die Speicherung aller Daten notwendig, die für die Erstellung der SQL-Abfragen benötigt werden. Demnach muss die Konsistenz und die Sicherung der Daten geprüft werden um einen einfachen Zugriff sicherzustellen.
\item \textbf{Benutzerverwaltung: }Die Benutzerverwaltung sorgt für die Speicherung der Spieleraccounts. In diesem Fall muss insbesondere die korrekte Rechtevergabe getestet werden.
\item \textbf{Ranglisten/Spielerprofile: }Die Profile halten den Fortschritt der Spieler fest, während die Ranglisten es ermöglichen, dass sich die Nutzer untereinander messen können. Daher ist es wichtig, dass alle zu erfassenden Daten in gewünschter Weise abgespeichert und angezeigt werden.
\item \textbf{Administrationstool: }Das Administrationstool ist das Werkzeug, welches benötigt wird damit die Dozenten und ihre Mitarbeiter das Spiel vorlesungsunterstützend einsetzen können. Die gesamte Hausaufgabenverwaltung läuft über dieses Tool. Demnach muss an dieser Stelle getestet werden, ob die Erstellung neuer Eingaben intuitiv und schnell machbar ist.
\end{itemize}

\section{Zu testende Funktionen/Merkmale}

Um die oben genannten Kernpunkte der Software effizient zu testen bietet sich an, die Produktfunktionen zu Hilfe zu nehmen. Zu diesem Zweck sind diese hier noch einmal aufgefürt und kurz umschrieben. 

\begin{itemize}
\item \textbf{$\langle$F10$\rangle$ Nutzer registrieren: }Neue Benutzer lassen sich durch Angabe von E-Mail/y-Adresse, sowie Passwort registrieren. Dabei wird auf die Vollständigkeit der Angaben geachtet und Studenten werden automatisch anhand der Eingaben erkannt.
\item \textbf{$\langle$F20$\rangle$ Nutzer anmelden: }Die Nutzer-Authentifizierung erkennt, ob es sich um einen registrierten Nutzer handelt und gewährt diesem Zugang.
\item \textbf{$\langle$F30$\rangle$ Nutzer abmelden: }Der Nutzer wird ordnungsgemäß abgemeldet und kann, ohne erneute Anmeldung, nicht mehr auf das Spiel zugreifen.
\item \textbf{$\langle$F40$\rangle$ Profil einsehen: }Das Profil wird auf allen Endgeräten korrekt und gut lesbar dargestellt. Alle angezeigten Daten sind richtig und aktuell.
\item \textbf{$\langle$F60$\rangle$ Passwort ändern: }Das Passwort wird geändert, der Passworthash in der Datenbank aktualisiert sich dabei. Anschließend muss sich der Nutzer mit dem neuen Passwort anmelden können, das alte Passwort ist nicht mehr gültig.
\item \textbf{$\langle$F70$\rangle$ Avatar ändern: }Die Spielfigur im Minispiel und das Icon das Nutzers werden geändert und korrekt dargestellt.
\item \textbf{$\langle$F90$\rangle$ Audioeinstellungen bearbeiten: }Soundeffekte und Musik können unabhängig voneinander ein- und ausgeschaltet werden. Die Einstellung wird korrekt in der Datenbank gespeichert und bei der nächsten Anmeldung korrekt geladen.
\item \textbf{$\langle$F100$\rangle$ Spielstand zurücksetzen: }Der Spielstand wird korrekt zurückgesetzt. Das Tutorial bleibt deaktiviert.
\item \textbf{$\langle$F110$\rangle$ Tutorial spielen: }Das Tutorial ist standardmäßig bei einem neuen Nutzer aktiviert, bis dieser das Tutorial erfolgreich beendet hat. Dann wird das Tutorial automatisch deaktiviert,  bis es im \glqq Settings\grqq-Menü erneut aktiviert wird.
\item \textbf{$\langle$F120$\rangle$ Story spielen: }Der Ablauf der Handlung ist korrekt und das Zusammenspiel von Minispiel und SQL-Modul funktioniert wie geplant.
\item \textbf{$\langle$F130$\rangle$ SQL-Trainer spielen: }Die Aufgaben wiederholen sich im Trivia-Modus nicht zu häufig. Im Story-Modus werden zu jedem Zeitpunkt die aktuellen Aufgaben gestellt. Zudem darf es nicht zu Fehlern kommen, die die Bearbeitung einschränken. Die Rückmeldung auf die Antwort der Nutzer ist korrekt. 
\item \textbf{$\langle$F140$\rangle$ Minispiel spielen: }Durch den zufälligen Aufruf der Level kommt es nicht zu Wiederholungen. Die Figur reagiert sofort auf Eingaben und das Spiel ist auf allen Endgeräten spielbar.
\item \textbf{$\langle$F150$\rangle$ Hausaufgaben bearbeiten: }Es werden die geforderten Aufgabenpakete geladen und die Bewertung funktioniert wie erwünscht. Bei der Bearbeitung darf es nicht zu Fehlern kommen, die den Betrieb einschränken.
\item \textbf{$\langle$F160$\rangle$ Ranglisten einsehen: }Die Ranglisten stellen alle geforderten Daten aktuell und richtig dar.
\item \textbf{$\langle$F170$\rangle$ Spieler suchen: }Spieler sollen anhand ihres Benutzernamens gesucht und korrekt angezeigt werden.
\item \textbf{$\langle$F180$\rangle$ Hausaufgabenergebnisse einsehen: }Die in den Hausaufgaben erzielten Ergebnisse werden ordnungsgemäß abgespeichert und für jeden Nutzer sind nur die eigenen Ergebnisse einsehbar.
\item \textbf{$\langle$F200$\rangle$ Benutzer Adminrechte geben: }Die Option kann nur von einem Admin genutzt werden und ernennt nur den richtigen Benutzer zum Admin.
\item \textbf{$\langle$F210$\rangle$ Trivia-Aufgabe erstellen: }Nur berechtigte Nutzer haben Zugriff auf diese Funktion und die Aufgaben werden korrekt und vollständig in die Datenbank eingepflegt.
\item \textbf{$\langle$F220$\rangle$ Benutzeraufgaben bewerten: }Die Bewertung kann nur von Admins oder beförderten Nutzern vorgenommen werden und wird korrekt mit den bereits vorhandenen Bewertungen verrechnet.
\item \textbf{$\langle$F230$\rangle$ Hausaufgaben erstellen: }Hausaufgaben können nur von Admins erstellt und nur von Studenten bearbeitet werden. Die Hausaufgaben sind nur innerhalb des angegebenen Bearbeitungszeitraums freigeschaltet.
\item \textbf{$\langle$Q10$\rangle$ Benutzerfreundlichkeit: }Alle Funktionen sind für den Nutzer verständlich und können über möglichst kurze Wege durch das Menü erreicht werden.
\item \textbf{$\langle$Q20$\rangle$ Zuverlässigkeit: }Das Spiel stürzt nicht ab und die Bearbeitung der Hausaufgaben ist technisch jederzeit möglich.
\item \textbf{$\langle$Q30$\rangle$ Korrektheit: }Die Auswertung der Benutzereingaben ist korrekt.
\item \textbf{$\langle$Q40$\rangle$ Plattformunabhängigkeit: }Das Spiel ist plattformunabhängig nutzbar.
\end{itemize}
 

\section{Nicht zu testende Funktionen}

Bei allen verwendeten Frameworks und Funktionen von Dritten werden ausreichende Testläufe vorausgesetzt. Daher werden keine weiteren Tests für die folgende Software vorgenommen:
\begin{itemize}
\item MelonJS (Framework)
\item play (Framework)
\item jQuery (Framework)
\item AngularJS (Framework)
\item Bootstrap (Framework)
\item automatische Generierung von Schemata und Statements (Teamprojekt)
\end{itemize}

\section{Vorgehen}

\textbf{a) Abnahme- und Funktionstests:} \\
Für den Abnahmetest ist folgendes Vorgehen geplant: Damit der Kunde einen guten Gesamtüberblick über alle Funktionalitäten erhält, sollen alle Anwendungsfälle aus der Anforderungsspezifikation in einer Reihenfolge getestet werden, in der auch spätere Nutzer die Applikation nutzen könnten. 
Dazu wird sich der Kunde zuerst einen neuen Account erstellen, dem dann der Administrator-Status zugewiesen wird. Mit diesem Account kann er zunächst, unabhängig vom eigentlichen Programm, die verschiedenen Funktionen des Administrationstools testen. Danach wird er sich für die eigentliche Applikation anmelden um die unterschiedlichen zur Verfügung stehenden Funktionen auszuprobieren und auch die verschiedenen Spielmodi anzuspielen. Zuletzt wird der Kunde dann noch die Abmeldung durchführen.
Während dieses Testlaufs kann sich der Kunde dann auch gleich ein Bild davon machen, inwieweit die im Pflichtenheft festgelegten Qualitätsstandards eingehalten wurden.\\

\newpage
 \textbf{b) Integrationstest:} \\
 Im Integrationstest wird für diese Software die Komunikation der beiden Komponenten getestet.\\
 Da die Komponenten über verschiedene Schnittstellen miteinander kommunizieren, werden für den Integrationstest die Funktionen nochmal genauer beleuchtet, die die jeweilige Schnittstelle benutzen. Dabei werden die Funktionen manuell mehrfach ausgeführt um die stabilität der Daten zu gewährleisten. Desweiteren werden die angezeigten Daten dabei mit den Daten in der Datenbank verglichen.  \\ 
 
 \textbf{c) Unittest:} \\
 Bei den Unit-Tests werden die einzelnen Komponenten für sich selbst überprüft. 
 Dies geschieht für das Back-End schon während der Programmierung. Da das Back-End zum Großteil eine Java-Basierte Anwendung ist wird beim Testen Gebrauch von JUnit gemacht, es wird also für jede erstellte Klasse direkt ein Test erstellt.
 Da das Front-End eine Javascript-basierte Anwendung ist und sich Unittests dafür nur etwas zeitaufwendiger umsetzen lassen wurde von diesen, in Absprache mit dem Protokoll-abnehmenden Institut, abgesehen.

\section{Testumgebung}
 Back-End Funktionen werden mit der JUnit getestet. Diese ist in das benutzte play!-Framework integriert.
Tests für Front-End Funktionen werden manuell durchgeführt.
 





%Der Testplan ist das zentrale Dokument der Qualitätssicherung und wird daher
%frühzeitig erstellt. Hier wird Umfang und Vorgehensweise der Qualitätssicherung
%beschrieben. Außerdem werden Testgegenstände und deren zu testenden
%Eigenschaften bzw. Funktionen identifiziert. Ferner werden die
%durchzuführenden Maßnahmen und die dafür verantwortlichen Personen definiert.
%Falls erforderlich sollte hier auch auf allgemeine Risiken eingegangen werden.


%\textbf{Dieses Kapitel kann aus der Abnahmetestspezifikation übernommen werden, 
%sollte jedoch die Bearbeitung der Annotationen beinhalten. Außerdem sollte das Unterkapitel 2.1 
%der zu testenden Komponenten überarbeitet werden.}
%
%\section{Zu testende Komponenten}
%
%Hier sind sämtliche zu testenden Objekte einschließlich der Versionsnummer aufzuführen.
%Ebenso ist anzugeben, auf welchem Medium die Software vorliegt, ob dies einen Einfluss auf Hardwareanforderungen hat
%und ob die Software vor Testbeginn in irgendeiner Weise transformiert werden muss. Außerdem wird auf zum
%Objekt gehörende Dokumentation der Komponente (Lasten-, Pflichtenheft, später auch Systementwurf) referenziert.


%\textbf{Anmerkung:}\\
%Dieses Dokument wird am Ende noch einmal zusammen mit den Testprotokollen in der Testspezifikation abgegeben.
%Da vorher im Systementwurf die Komponenten benannt und nummeriert wurden, sollten diese für die zweite Abgabe erweitert %werden,
%so dass eine Verbindung zwischen dem Systementwurf und diesem Dokument entsteht.


%\section{Zu testende Funktionen/Merkmale}

%Dieser Punkt beinhaltet alle Eigenschaften bzw. Funktionen und deren
%Kombinationen, die zu testen sind.

%Sämtliche Funktionalitäten, die getestet werden sollen, werden hier aufgeführt.
%Dabei sind auf die vorangegangenen Dokumentationen zu referenzieren
%(Pflichtenheft) und die dortigen Funktions-IDs zu verwenden!

%Beispiel:
%\begin{itemize}
%\item \textbf{F20}
%\item \textbf{Q10}
%\end{itemize}
 

%\section{Nicht zu testende Funktionen}

%(optional; auszufüllen, falls es Funktionen gibt, die nicht getestet werden
%sollen)\\

%Hier werden alle Eigenschaften bzw. Funktionen und Funktionskombinationen
%aufgelistet, die nicht getestet werden.
%\textbf{ Es sollte begründet werden, warum diese nicht getestet werden.} Es
%versteht sich von selber, dass alle Muss-Funktionalitäten des Pflichtenheftes getestet werden müssen.

%\section{Vorgehen}

%Die allgemeinen Vorgehensweisen für die einzelnen zu testenden Funktionen und
%Funktionskombinationen werden hier beschrieben. Die Beschreibung sollte
%detailliert genug sein, um die Hauptaktivitäten und deren Zeitbedarf abschätzen
%zu können.

%Es ist zu beachten, dass für alle wichtigen Funktionalitäten das Verfahren
%angegeben wird. Dies gewährleistet, dass diese Funktionalitäten adäquat
%getestet werden.

%Es ist zu dokumentieren, welche Aktivitäten, Techniken und Werkzeuge benötigt
%werden, damit die Funktionalitäten getestet werden können.

%Beispiel für Vorgehen (unvollständige Liste):\\
%a) Abnahme- und Funktionstests\\
%Die Anwendungsfälle aus der Anforderungsspezifikation werden über das
%Web-Interface geprüft. Mindestanforderung hierfür ist es, jeden Fall einmal auf
%seine korrekte Funktionalität zu testen.\\
%b) Komponenten- und Integrationstests\\
%Klassen werden mit JUnit-Testfällen geprüft. Vor Beginn der Implementierung
%werden bereits Blackbox-Testfälle erstellt, die dann begleitend zur
%Implementierung genutzt werden ("`Test first"'). Nach Abschluss der
%Implementierung einer Komponente wird diese dann durch Whitebox-Tests
%geprüft.\\
%Der Integrationstest der Klassen und Komponenten erfolgt nach dem
%Bottom-Up-Prinzip. Anfangs muss die Integration der Datenbankanbindung und den
%entsprechenden Data-Access-Objects (DAO) geprüft werden, da das Mapping der
%Datenbank auf Objekte die unterste Schicht des Projektes bildet. Dieser
%Testabschnitt wird durch die Schnittstellentests abgedeckt.
%Die Komponenten werden damit unter Berücksichtigung ihrer Abhängigkeiten
%konkret in folgender Reihenfolge integriert: \ldots\\
%(Hier kommt das konkrete Vorgehen bei der Integration: Welche Klassen werden
%zusammen getestet, welche kommen dann dazu etc. Das kann man z.B. auch schön in
%Form eines Baumes aufzeigen.)
%c) \ldots

%Das Kapitel wird im Laufe des Projekt ergänzt. In der ersten Iteration ist vor allem auf die Abnahmetests einzugehen.

%\section{Testumgebung}

%Die genutzte Testumgebung(en) bitte hier angeben und kurz beschreiben.\\
%Beispiel: JUnit Testsuite, lokal installierter Web Application Server, \ldots

%Bei Abnahmetest sollte die Testumgebung der Produktumgebung entsprechen.
